/*
 * Subset of Influx API covered by Influx CLI
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 2.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// Expression - struct for Expression
type Expression struct {
	ArrayExpression        *ArrayExpression
	BinaryExpression       *BinaryExpression
	BooleanLiteral         *BooleanLiteral
	CallExpression         *CallExpression
	ConditionalExpression  *ConditionalExpression
	DateTimeLiteral        *DateTimeLiteral
	DictExpression         *DictExpression
	DurationLiteral        *DurationLiteral
	FloatLiteral           *FloatLiteral
	FunctionExpression     *FunctionExpression
	Identifier             *Identifier
	IndexExpression        *IndexExpression
	IntegerLiteral         *IntegerLiteral
	LogicalExpression      *LogicalExpression
	MemberExpression       *MemberExpression
	ObjectExpression       *ObjectExpression
	ParenExpression        *ParenExpression
	PipeExpression         *PipeExpression
	PipeLiteral            *PipeLiteral
	RegexpLiteral          *RegexpLiteral
	StringLiteral          *StringLiteral
	UnaryExpression        *UnaryExpression
	UnsignedIntegerLiteral *UnsignedIntegerLiteral
}

// ArrayExpressionAsExpression is a convenience function that returns ArrayExpression wrapped in Expression
func ArrayExpressionAsExpression(v *ArrayExpression) Expression {
	return Expression{ArrayExpression: v}
}

// BinaryExpressionAsExpression is a convenience function that returns BinaryExpression wrapped in Expression
func BinaryExpressionAsExpression(v *BinaryExpression) Expression {
	return Expression{BinaryExpression: v}
}

// BooleanLiteralAsExpression is a convenience function that returns BooleanLiteral wrapped in Expression
func BooleanLiteralAsExpression(v *BooleanLiteral) Expression {
	return Expression{BooleanLiteral: v}
}

// CallExpressionAsExpression is a convenience function that returns CallExpression wrapped in Expression
func CallExpressionAsExpression(v *CallExpression) Expression {
	return Expression{CallExpression: v}
}

// ConditionalExpressionAsExpression is a convenience function that returns ConditionalExpression wrapped in Expression
func ConditionalExpressionAsExpression(v *ConditionalExpression) Expression {
	return Expression{ConditionalExpression: v}
}

// DateTimeLiteralAsExpression is a convenience function that returns DateTimeLiteral wrapped in Expression
func DateTimeLiteralAsExpression(v *DateTimeLiteral) Expression {
	return Expression{DateTimeLiteral: v}
}

// DictExpressionAsExpression is a convenience function that returns DictExpression wrapped in Expression
func DictExpressionAsExpression(v *DictExpression) Expression {
	return Expression{DictExpression: v}
}

// DurationLiteralAsExpression is a convenience function that returns DurationLiteral wrapped in Expression
func DurationLiteralAsExpression(v *DurationLiteral) Expression {
	return Expression{DurationLiteral: v}
}

// FloatLiteralAsExpression is a convenience function that returns FloatLiteral wrapped in Expression
func FloatLiteralAsExpression(v *FloatLiteral) Expression {
	return Expression{FloatLiteral: v}
}

// FunctionExpressionAsExpression is a convenience function that returns FunctionExpression wrapped in Expression
func FunctionExpressionAsExpression(v *FunctionExpression) Expression {
	return Expression{FunctionExpression: v}
}

// IdentifierAsExpression is a convenience function that returns Identifier wrapped in Expression
func IdentifierAsExpression(v *Identifier) Expression {
	return Expression{Identifier: v}
}

// IndexExpressionAsExpression is a convenience function that returns IndexExpression wrapped in Expression
func IndexExpressionAsExpression(v *IndexExpression) Expression {
	return Expression{IndexExpression: v}
}

// IntegerLiteralAsExpression is a convenience function that returns IntegerLiteral wrapped in Expression
func IntegerLiteralAsExpression(v *IntegerLiteral) Expression {
	return Expression{IntegerLiteral: v}
}

// LogicalExpressionAsExpression is a convenience function that returns LogicalExpression wrapped in Expression
func LogicalExpressionAsExpression(v *LogicalExpression) Expression {
	return Expression{LogicalExpression: v}
}

// MemberExpressionAsExpression is a convenience function that returns MemberExpression wrapped in Expression
func MemberExpressionAsExpression(v *MemberExpression) Expression {
	return Expression{MemberExpression: v}
}

// ObjectExpressionAsExpression is a convenience function that returns ObjectExpression wrapped in Expression
func ObjectExpressionAsExpression(v *ObjectExpression) Expression {
	return Expression{ObjectExpression: v}
}

// ParenExpressionAsExpression is a convenience function that returns ParenExpression wrapped in Expression
func ParenExpressionAsExpression(v *ParenExpression) Expression {
	return Expression{ParenExpression: v}
}

// PipeExpressionAsExpression is a convenience function that returns PipeExpression wrapped in Expression
func PipeExpressionAsExpression(v *PipeExpression) Expression {
	return Expression{PipeExpression: v}
}

// PipeLiteralAsExpression is a convenience function that returns PipeLiteral wrapped in Expression
func PipeLiteralAsExpression(v *PipeLiteral) Expression {
	return Expression{PipeLiteral: v}
}

// RegexpLiteralAsExpression is a convenience function that returns RegexpLiteral wrapped in Expression
func RegexpLiteralAsExpression(v *RegexpLiteral) Expression {
	return Expression{RegexpLiteral: v}
}

// StringLiteralAsExpression is a convenience function that returns StringLiteral wrapped in Expression
func StringLiteralAsExpression(v *StringLiteral) Expression {
	return Expression{StringLiteral: v}
}

// UnaryExpressionAsExpression is a convenience function that returns UnaryExpression wrapped in Expression
func UnaryExpressionAsExpression(v *UnaryExpression) Expression {
	return Expression{UnaryExpression: v}
}

// UnsignedIntegerLiteralAsExpression is a convenience function that returns UnsignedIntegerLiteral wrapped in Expression
func UnsignedIntegerLiteralAsExpression(v *UnsignedIntegerLiteral) Expression {
	return Expression{UnsignedIntegerLiteral: v}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *Expression) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ArrayExpression
	err = json.Unmarshal(data, &dst.ArrayExpression)
	if err == nil {
		jsonArrayExpression, _ := json.Marshal(dst.ArrayExpression)
		if string(jsonArrayExpression) == "{}" { // empty struct
			dst.ArrayExpression = nil
		} else {
			match++
		}
	} else {
		dst.ArrayExpression = nil
	}

	// try to unmarshal data into BinaryExpression
	err = json.Unmarshal(data, &dst.BinaryExpression)
	if err == nil {
		jsonBinaryExpression, _ := json.Marshal(dst.BinaryExpression)
		if string(jsonBinaryExpression) == "{}" { // empty struct
			dst.BinaryExpression = nil
		} else {
			match++
		}
	} else {
		dst.BinaryExpression = nil
	}

	// try to unmarshal data into BooleanLiteral
	err = json.Unmarshal(data, &dst.BooleanLiteral)
	if err == nil {
		jsonBooleanLiteral, _ := json.Marshal(dst.BooleanLiteral)
		if string(jsonBooleanLiteral) == "{}" { // empty struct
			dst.BooleanLiteral = nil
		} else {
			match++
		}
	} else {
		dst.BooleanLiteral = nil
	}

	// try to unmarshal data into CallExpression
	err = json.Unmarshal(data, &dst.CallExpression)
	if err == nil {
		jsonCallExpression, _ := json.Marshal(dst.CallExpression)
		if string(jsonCallExpression) == "{}" { // empty struct
			dst.CallExpression = nil
		} else {
			match++
		}
	} else {
		dst.CallExpression = nil
	}

	// try to unmarshal data into ConditionalExpression
	err = json.Unmarshal(data, &dst.ConditionalExpression)
	if err == nil {
		jsonConditionalExpression, _ := json.Marshal(dst.ConditionalExpression)
		if string(jsonConditionalExpression) == "{}" { // empty struct
			dst.ConditionalExpression = nil
		} else {
			match++
		}
	} else {
		dst.ConditionalExpression = nil
	}

	// try to unmarshal data into DateTimeLiteral
	err = json.Unmarshal(data, &dst.DateTimeLiteral)
	if err == nil {
		jsonDateTimeLiteral, _ := json.Marshal(dst.DateTimeLiteral)
		if string(jsonDateTimeLiteral) == "{}" { // empty struct
			dst.DateTimeLiteral = nil
		} else {
			match++
		}
	} else {
		dst.DateTimeLiteral = nil
	}

	// try to unmarshal data into DictExpression
	err = json.Unmarshal(data, &dst.DictExpression)
	if err == nil {
		jsonDictExpression, _ := json.Marshal(dst.DictExpression)
		if string(jsonDictExpression) == "{}" { // empty struct
			dst.DictExpression = nil
		} else {
			match++
		}
	} else {
		dst.DictExpression = nil
	}

	// try to unmarshal data into DurationLiteral
	err = json.Unmarshal(data, &dst.DurationLiteral)
	if err == nil {
		jsonDurationLiteral, _ := json.Marshal(dst.DurationLiteral)
		if string(jsonDurationLiteral) == "{}" { // empty struct
			dst.DurationLiteral = nil
		} else {
			match++
		}
	} else {
		dst.DurationLiteral = nil
	}

	// try to unmarshal data into FloatLiteral
	err = json.Unmarshal(data, &dst.FloatLiteral)
	if err == nil {
		jsonFloatLiteral, _ := json.Marshal(dst.FloatLiteral)
		if string(jsonFloatLiteral) == "{}" { // empty struct
			dst.FloatLiteral = nil
		} else {
			match++
		}
	} else {
		dst.FloatLiteral = nil
	}

	// try to unmarshal data into FunctionExpression
	err = json.Unmarshal(data, &dst.FunctionExpression)
	if err == nil {
		jsonFunctionExpression, _ := json.Marshal(dst.FunctionExpression)
		if string(jsonFunctionExpression) == "{}" { // empty struct
			dst.FunctionExpression = nil
		} else {
			match++
		}
	} else {
		dst.FunctionExpression = nil
	}

	// try to unmarshal data into Identifier
	err = json.Unmarshal(data, &dst.Identifier)
	if err == nil {
		jsonIdentifier, _ := json.Marshal(dst.Identifier)
		if string(jsonIdentifier) == "{}" { // empty struct
			dst.Identifier = nil
		} else {
			match++
		}
	} else {
		dst.Identifier = nil
	}

	// try to unmarshal data into IndexExpression
	err = json.Unmarshal(data, &dst.IndexExpression)
	if err == nil {
		jsonIndexExpression, _ := json.Marshal(dst.IndexExpression)
		if string(jsonIndexExpression) == "{}" { // empty struct
			dst.IndexExpression = nil
		} else {
			match++
		}
	} else {
		dst.IndexExpression = nil
	}

	// try to unmarshal data into IntegerLiteral
	err = json.Unmarshal(data, &dst.IntegerLiteral)
	if err == nil {
		jsonIntegerLiteral, _ := json.Marshal(dst.IntegerLiteral)
		if string(jsonIntegerLiteral) == "{}" { // empty struct
			dst.IntegerLiteral = nil
		} else {
			match++
		}
	} else {
		dst.IntegerLiteral = nil
	}

	// try to unmarshal data into LogicalExpression
	err = json.Unmarshal(data, &dst.LogicalExpression)
	if err == nil {
		jsonLogicalExpression, _ := json.Marshal(dst.LogicalExpression)
		if string(jsonLogicalExpression) == "{}" { // empty struct
			dst.LogicalExpression = nil
		} else {
			match++
		}
	} else {
		dst.LogicalExpression = nil
	}

	// try to unmarshal data into MemberExpression
	err = json.Unmarshal(data, &dst.MemberExpression)
	if err == nil {
		jsonMemberExpression, _ := json.Marshal(dst.MemberExpression)
		if string(jsonMemberExpression) == "{}" { // empty struct
			dst.MemberExpression = nil
		} else {
			match++
		}
	} else {
		dst.MemberExpression = nil
	}

	// try to unmarshal data into ObjectExpression
	err = json.Unmarshal(data, &dst.ObjectExpression)
	if err == nil {
		jsonObjectExpression, _ := json.Marshal(dst.ObjectExpression)
		if string(jsonObjectExpression) == "{}" { // empty struct
			dst.ObjectExpression = nil
		} else {
			match++
		}
	} else {
		dst.ObjectExpression = nil
	}

	// try to unmarshal data into ParenExpression
	err = json.Unmarshal(data, &dst.ParenExpression)
	if err == nil {
		jsonParenExpression, _ := json.Marshal(dst.ParenExpression)
		if string(jsonParenExpression) == "{}" { // empty struct
			dst.ParenExpression = nil
		} else {
			match++
		}
	} else {
		dst.ParenExpression = nil
	}

	// try to unmarshal data into PipeExpression
	err = json.Unmarshal(data, &dst.PipeExpression)
	if err == nil {
		jsonPipeExpression, _ := json.Marshal(dst.PipeExpression)
		if string(jsonPipeExpression) == "{}" { // empty struct
			dst.PipeExpression = nil
		} else {
			match++
		}
	} else {
		dst.PipeExpression = nil
	}

	// try to unmarshal data into PipeLiteral
	err = json.Unmarshal(data, &dst.PipeLiteral)
	if err == nil {
		jsonPipeLiteral, _ := json.Marshal(dst.PipeLiteral)
		if string(jsonPipeLiteral) == "{}" { // empty struct
			dst.PipeLiteral = nil
		} else {
			match++
		}
	} else {
		dst.PipeLiteral = nil
	}

	// try to unmarshal data into RegexpLiteral
	err = json.Unmarshal(data, &dst.RegexpLiteral)
	if err == nil {
		jsonRegexpLiteral, _ := json.Marshal(dst.RegexpLiteral)
		if string(jsonRegexpLiteral) == "{}" { // empty struct
			dst.RegexpLiteral = nil
		} else {
			match++
		}
	} else {
		dst.RegexpLiteral = nil
	}

	// try to unmarshal data into StringLiteral
	err = json.Unmarshal(data, &dst.StringLiteral)
	if err == nil {
		jsonStringLiteral, _ := json.Marshal(dst.StringLiteral)
		if string(jsonStringLiteral) == "{}" { // empty struct
			dst.StringLiteral = nil
		} else {
			match++
		}
	} else {
		dst.StringLiteral = nil
	}

	// try to unmarshal data into UnaryExpression
	err = json.Unmarshal(data, &dst.UnaryExpression)
	if err == nil {
		jsonUnaryExpression, _ := json.Marshal(dst.UnaryExpression)
		if string(jsonUnaryExpression) == "{}" { // empty struct
			dst.UnaryExpression = nil
		} else {
			match++
		}
	} else {
		dst.UnaryExpression = nil
	}

	// try to unmarshal data into UnsignedIntegerLiteral
	err = json.Unmarshal(data, &dst.UnsignedIntegerLiteral)
	if err == nil {
		jsonUnsignedIntegerLiteral, _ := json.Marshal(dst.UnsignedIntegerLiteral)
		if string(jsonUnsignedIntegerLiteral) == "{}" { // empty struct
			dst.UnsignedIntegerLiteral = nil
		} else {
			match++
		}
	} else {
		dst.UnsignedIntegerLiteral = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ArrayExpression = nil
		dst.BinaryExpression = nil
		dst.BooleanLiteral = nil
		dst.CallExpression = nil
		dst.ConditionalExpression = nil
		dst.DateTimeLiteral = nil
		dst.DictExpression = nil
		dst.DurationLiteral = nil
		dst.FloatLiteral = nil
		dst.FunctionExpression = nil
		dst.Identifier = nil
		dst.IndexExpression = nil
		dst.IntegerLiteral = nil
		dst.LogicalExpression = nil
		dst.MemberExpression = nil
		dst.ObjectExpression = nil
		dst.ParenExpression = nil
		dst.PipeExpression = nil
		dst.PipeLiteral = nil
		dst.RegexpLiteral = nil
		dst.StringLiteral = nil
		dst.UnaryExpression = nil
		dst.UnsignedIntegerLiteral = nil

		return fmt.Errorf("Data matches more than one schema in oneOf(Expression)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf(Expression)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Expression) MarshalJSON() ([]byte, error) {
	if src.ArrayExpression != nil {
		return json.Marshal(&src.ArrayExpression)
	}

	if src.BinaryExpression != nil {
		return json.Marshal(&src.BinaryExpression)
	}

	if src.BooleanLiteral != nil {
		return json.Marshal(&src.BooleanLiteral)
	}

	if src.CallExpression != nil {
		return json.Marshal(&src.CallExpression)
	}

	if src.ConditionalExpression != nil {
		return json.Marshal(&src.ConditionalExpression)
	}

	if src.DateTimeLiteral != nil {
		return json.Marshal(&src.DateTimeLiteral)
	}

	if src.DictExpression != nil {
		return json.Marshal(&src.DictExpression)
	}

	if src.DurationLiteral != nil {
		return json.Marshal(&src.DurationLiteral)
	}

	if src.FloatLiteral != nil {
		return json.Marshal(&src.FloatLiteral)
	}

	if src.FunctionExpression != nil {
		return json.Marshal(&src.FunctionExpression)
	}

	if src.Identifier != nil {
		return json.Marshal(&src.Identifier)
	}

	if src.IndexExpression != nil {
		return json.Marshal(&src.IndexExpression)
	}

	if src.IntegerLiteral != nil {
		return json.Marshal(&src.IntegerLiteral)
	}

	if src.LogicalExpression != nil {
		return json.Marshal(&src.LogicalExpression)
	}

	if src.MemberExpression != nil {
		return json.Marshal(&src.MemberExpression)
	}

	if src.ObjectExpression != nil {
		return json.Marshal(&src.ObjectExpression)
	}

	if src.ParenExpression != nil {
		return json.Marshal(&src.ParenExpression)
	}

	if src.PipeExpression != nil {
		return json.Marshal(&src.PipeExpression)
	}

	if src.PipeLiteral != nil {
		return json.Marshal(&src.PipeLiteral)
	}

	if src.RegexpLiteral != nil {
		return json.Marshal(&src.RegexpLiteral)
	}

	if src.StringLiteral != nil {
		return json.Marshal(&src.StringLiteral)
	}

	if src.UnaryExpression != nil {
		return json.Marshal(&src.UnaryExpression)
	}

	if src.UnsignedIntegerLiteral != nil {
		return json.Marshal(&src.UnsignedIntegerLiteral)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *Expression) GetActualInstance() interface{} {
	if obj.ArrayExpression != nil {
		return obj.ArrayExpression
	}

	if obj.BinaryExpression != nil {
		return obj.BinaryExpression
	}

	if obj.BooleanLiteral != nil {
		return obj.BooleanLiteral
	}

	if obj.CallExpression != nil {
		return obj.CallExpression
	}

	if obj.ConditionalExpression != nil {
		return obj.ConditionalExpression
	}

	if obj.DateTimeLiteral != nil {
		return obj.DateTimeLiteral
	}

	if obj.DictExpression != nil {
		return obj.DictExpression
	}

	if obj.DurationLiteral != nil {
		return obj.DurationLiteral
	}

	if obj.FloatLiteral != nil {
		return obj.FloatLiteral
	}

	if obj.FunctionExpression != nil {
		return obj.FunctionExpression
	}

	if obj.Identifier != nil {
		return obj.Identifier
	}

	if obj.IndexExpression != nil {
		return obj.IndexExpression
	}

	if obj.IntegerLiteral != nil {
		return obj.IntegerLiteral
	}

	if obj.LogicalExpression != nil {
		return obj.LogicalExpression
	}

	if obj.MemberExpression != nil {
		return obj.MemberExpression
	}

	if obj.ObjectExpression != nil {
		return obj.ObjectExpression
	}

	if obj.ParenExpression != nil {
		return obj.ParenExpression
	}

	if obj.PipeExpression != nil {
		return obj.PipeExpression
	}

	if obj.PipeLiteral != nil {
		return obj.PipeLiteral
	}

	if obj.RegexpLiteral != nil {
		return obj.RegexpLiteral
	}

	if obj.StringLiteral != nil {
		return obj.StringLiteral
	}

	if obj.UnaryExpression != nil {
		return obj.UnaryExpression
	}

	if obj.UnsignedIntegerLiteral != nil {
		return obj.UnsignedIntegerLiteral
	}

	// all schemas are nil
	return nil
}

type NullableExpression struct {
	value *Expression
	isSet bool
}

func (v NullableExpression) Get() *Expression {
	return v.value
}

func (v *NullableExpression) Set(val *Expression) {
	v.value = val
	v.isSet = true
}

func (v NullableExpression) IsSet() bool {
	return v.isSet
}

func (v *NullableExpression) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableExpression(val *Expression) *NullableExpression {
	return &NullableExpression{value: val, isSet: true}
}

func (v NullableExpression) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableExpression) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
